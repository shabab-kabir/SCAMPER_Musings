;; CSC 151 (Spring '23)
;; Lab: Waveforms (waveforms.scm)
;; Authors: Shabab Kabir, Ashmit Bindal, & Shibam Mukhopadhyay
;; Date: 10 April 2023
;; Acknowledgements:
;;   The super random smell of manure and also Ben's amazing guitar playing; but also just Ben.

(import audio)

;; In today's lab, we'll apply the concepts of digital audio we learned in the
;; reading to synthesize sounds. We'll first warm up by writing some basic
;; functions that manipulate the common quantities found in digital audio, then
;; we'll go through creating simple waveforms with the audio library.
;;
;; Throughout this lab, alternate partners with every function that you
;; implement!

;; ----------------------
"Problem 1: Calculations"
;; ----------------------

;; The reading introduced a number of key concepts regarding acoustic sound
;; waves. In this problem, we'll review these concepts by writing a few
;; quick helper functions that we will find useful in generating waveforms.
;; Recall the following definitions:
;;
;; Sample: an discrete data point taken from a (continuous) sound wave.
;; Duration: the length of a clip (in seconds).
;; Clip: a collection of samples that represents a sound wave.
;; Sample rate: the number of samples recorded per second (in hertz, Hz).
;; Waveforms: a sequence of samples that forms a repeated pattern.
;; Amplitude: the amount of pressure generated by a sound wave at a given point
;;            in time, i.e., its value.
;; Frequency: the number of occurrences a single soundwave pattern per second
;;            (in hertz, Hz)

;; First, here are some common sample rates that you encounter in the wild.
;; "CD-quality" audio is usually recorded at either 44.1 kHz (44100 Hz).

(define low-quality 16000)
(define medium-quality 32000)
(define high-quality 44100)

;; Let's write a function that given a sample rate and duration, calculates
;; the number of samples that the resulting clip will contain:

;;; (rate->samples-per-clip sample-rate duration) -> number?
;;;   sample-rate: number?, a non-negative integer
;;;   duration: number?, a non-negative number
;;; Returns the number of samples of a clip with the given sample rate and
;;; duration. 
(define rate->samples-per-clip
  (lambda (sample-rate duration)
    (* sample-rate duration)))

(test-case "rate->samples-per-clip example 1"
  = (rate->sample-per-clip high-quality 1) 44100)

(test-case "rate->samples-per-clip example 2"
  = (rate->samples-per-clip high-quality 2) 88200)

(test-case "rate->samples-per-clip example 3"
  = (rate->samples-per-clip low-quality 1) 16000)

(test-case "rate-samples-per-clip example 4"
  = (rate->samples-per-clip low-quality 2) 32000)

;; With rate->samples-per-clip in hand, we can briefly explore how much
;; memory the clips we generate will take. Note that we won't use this data
;; directly in generating waveforms, but it is nice to know the physical
;; size of the data we're working with! Implement samples->size and explore
;; how big these sound clips can be!
;;
;; (Note: if you are familiar with metric prefixes, you'll find the
;; calculations described in the documentation comment below odd. This is
;; because computing has a tradition of using base-2 for describing quantities
;; instead of base-10!)

;;; (samples->size samples) -> number?
;;;   samples: number?, a non-negative integer
;;; Returns the size of the given number of audio samples in megabytes (MiB).
;;; Each sample is takes up 4 bytes of memory and there is 1024 bytes in a KiB
;;; and 1024 KiB in a MiB.
(define samples->size
  (lambda (samples)
    (/ (/ (* samples 4) 1024) 1024)))

(test-case "samples->size example 1"
  (=-eps 0.01) (samples->size (rate->samples-per-clip high-quality 60)) 10.094)

(test-case "sample->size example 2"
  (=-eps 0.01) (samples->size (rate->samples-per-clip medium-quality 60)) 7.32)

(test-case "sample->size example 3"
  (=-eps 0.01) (samples->size (rate->samples-per-clip low-quality 60)) 3.66)

;;; https://en.wikipedia.org/wiki/Piano_key_frequencies
(define middle-c 261.63)
(define a4 440)
(define bf5 932.33)

;;; (number-of-waves sample-rate frequency) -> number?
;;;   sample-rate: number?, a non-negative integer
;;;   frequency: number?, a non-negative number 
;;; Returns the number of samples per waveform for a given sample rate and
;;; frequncy of wave pattern.
(define samples-per-wave
  (lambda (sample-rate frequency)
    (/ sample-rate frequency)))

(test-case "samples-per-wave example 1"
  (=-eps 0.01) (samples-per-wave high-quality middle-c) 168.56)

(test-case "samples-per-wave example 2"
  (=-eps 0.01) (samples-per-wave low-quality a4) 36.36)

(test-case "samples-per-wave example 3"
  (=-eps 0.01) (samples-per-wave medium-quality bf5) 34.32)

;;; (waves-per-clip frequency duration) -> number?
;;;   frequency: number?, a non-negative number 
;;;   duration: number?, a non-negative number
;;; Returns the number of waveforms found within a given clip.
(define waves-per-clip
  (lambda (sample-rate duration frequency)
          (* frequency duration)))

(test-case "waves-per-clip example 1"
  (=-eps 0.01) (waves-per-clip high-quality 1 middle-c) 261.63)

(test-case "waves-per-clip example 2"
  (=-eps 0.01) (waves-per-clip medium-quality 2 a4) 880.0)

(test-case "waves-per-clip example 3"
  (=-eps 0.01) (waves-per-clip low-quality 60 bf5) 55939.8)

;; ---------------------------
"Problem 2: A Simple Waveform"
;; ---------------------------

;; Next, let's draw our attention towards generating a waveform!
;; The key function we will use here is sample-node from the
;; audio library:
;;
;; (sample-node data): audio-node?
;;   data: vector?, a vector of numbers in the range (-1.0, 1.0)
;; Creates a new audio node that plays the given sample data.
;;
;; Seems fairly straightforward to use, right? sample-node takes
;; a vector of numbers representing the samples of a clip and
;; creates a audio clip playable in our output. But wait, what
;; is this vector thing? For our purposes, a vector is simply a more
;; efficient list. We can create a vector using the vector function
;; analogously to the list function.

(define example-vector-1
  (vector 1 2 3 4 5))

example-vector-1

;; Importantly for our purposes, we can generate ranges of numbers
;; in vectors with the vector-range function and map over a vector
;; using vector-map:

(define example-vector-2
  (vector-range 0 100 3))

(vector-map (lambda (n) (- n 1)) example-vector-2)

;; This efficiency comes at a price: we can't easily decompose a
;; vector recursively in terms of its "head" and "tail". But luckily,
;; for generating sound, we don't need this functionality!
;;
;; With this in mind, here's a sample audio clip that generates
;; white noise, a clip with random amplitudes for each sample.
;; Note that this clip comes in loud, so make sure to turn down your
;; headphones before you play it.

 ;; N.B., 32000 samples = 16000 Hz clip played for 2 seconds,
 ;; ideally calculated from rate->samples-per-clip!
(sample-node
  (let ([num-samples 32000])
    (|> (vector-range num-samples)
        (lambda (v) (vector-map (lambda (n) (- (random 2) 1)) v)))))

;; The visualizer for these audio clips includes an oscilloscope,
;; a visualization of the wave over time. You can see that the
;; wave is essentially random values with no discernible pattern.
;;
;; Another thing to note is the values themselves: recall that
;; (random n) generates a random integer in the range [0, n). So
;; (- (random 2) 1) generates a random integer in the range [-1, 1)!
;; Our sound samples are not arbitrary integers, but floating point
;; numbers in the range -1.0 and 1.0. This is because the actual
;; amplitude of a sound wave is dependent on the device that produces
;; it, e.g., a stadium speaker system is capable of larger amplitudes
;; than a pair of cheap earbuds. So rather than picking absolute 
;; amplitudes, we'll normalize the amplitudes instead.

;; With this in mind, let's create our first waveform, a square
;; wave:
;;
;; https://en.wikipedia.org/wiki/Square_wave
;;
;; An individual waveform of a square wave looks as follows:
;; + For the first half of the waveform, the amplitude is -1.0
;; + For the second half of the waveform, the amplitude is 1.0
;;
;; Proceed by doing the following:
;; + Use vector-range to create a vector of numbers from 0 to the
;;   number of expected samples in the clip.
;; + Transform the ith element of the vector into an appropriate
;;   value for the waveform.
;;
;; As described in class, using a combination of samples-per-wave
;; and remainder will allow to take an index from range into a
;; index into an individual wave.

(sample-node
  (let ([num-samples 32000])
    (|> (vector-range num-samples)
        (lambda (v) (vector-map (lambda (n) (- (random 2) 1)) v)))))

(define square-sample
  (lambda (sample-rate frequency duration)
    (let* ([num-samples (* sample-rate duration)]
           [samples-per-wave (round (/ sample-rate frequency))]
           [samples-per-half-wave (round (/ samples-per-wave 2))])
      (|> (vector-range num-samples)
          (lambda (v)
            (let* ([wave-index (floor (* (/ v sample-rate) frequency))]
                   [remainder (modulo v samples-per-wave)])
              (if (< remainder samples-per-half-wave) -1.0 1.0)))))))

(square-sample medium-quality middle-c 1)

;; ------------------------
"Problem 3: More waveforms"
;; ------------------------

;; Next, let's create a few more fundamental waveforms!
;;
;; Sawtooth: https://en.wikipedia.org/wiki/Sawtooth_wave
;; + The amplitude linearly increases from -1.0 to 1.0.
;; Triangle: https://en.wikipedia.org/wiki/Triangle_wave
;; + In the first half of the waveform the amplitude linearly
;;   increases from -1.0 to 1.0.
;; + In the second half of the waveform the amplitude linearly
;;   decreases from 1.0 to -1.0.
;; Sine: https://en.wikipedia.org/wiki/Sine_wave
;; + The amplitude varies per one cycle of a sine wave.
;;
;; For this last function, recall that the period of a sine wave
;; is 2 * pi radians. So you will need to chop up the inputs to
;; sine to be fractions of 2 * pi according to which sample of the
;; waveform you are mapping.
;;
;; Add appropriate invocations of your samples below to try them
;; out! Remember that you should specify medium-quality (16000 Hz)
;; for your function invocations.
(define sawtooth-sample
  (lambda (sample-rate frequency duration)
    (let* ([num-samples (* sample-rate duration)]
           [samples-per-wave (round (/ sample-rate frequency))]
           [amplitude-increment (/ 2.0 samples-per-wave)])
      (|> (vector-range num-samples)
          (lambda (v)
            (let* ([wave-index (floor (* (/ v sample-rate) frequency))]
                   [remainder (modulo v samples-per-wave)]
                   [amplitude (* amplitude-increment remainder)])
              (- amplitude 1.0)))))))

(sawtooth-sample medium-quality 1 1)

(define triangle-sample
  (lambda (sample-rate frequency duration)
    (let* ([num-samples (* sample-rate duration)]
           [samples-per-wave (round (/ sample-rate frequency))]
           [amplitude-increment (/ 2.0 samples-per-wave)])
      (|> (vector-range num-samples)
          (lambda (v)
            (let* ([wave-index (floor (* (/ v sample-rate) frequency))]
                   [remainder (modulo v samples-per-wave)]
                   [amplitude (* amplitude-increment remainder)]
                   [half-wave (floor (/ samples-per-wave 2))])
              (if (< remainder half-wave)
                  (- amplitude 1.0)
                  (- 1.0 amplitude))))))))

(triangle-sample medium-quality 1 1)

(define sine-sample
  (lambda (sample-rate frequency duration)
    (let* ([num-samples (* sample-rate duration)]
           [samples-per-wave (round (/ sample-rate frequency))]
           [radians-per-sample (* 2.0 pi (/ frequency sample-rate))])
      (|> (vector-range num-samples)
          (lambda (v)
            (* (sin (* radians-per-sample v)) 1.0))))))

(sine-sample medium-quality 1 1)